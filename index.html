<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hardcore Arena Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* HUD ELEMENTS */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        #top-bar {
            padding: 20px; display: flex; justify-content: space-between; align-items: center;
            font-weight: bold; font-size: 24px; color: white; text-shadow: 2px 2px 0 #000;
        }

        /* PLAYER HEALTH BAR */
        #health-container {
            width: 300px; height: 30px; background: #333; border: 2px solid white; position: relative;
        }
        #health-fill {
            width: 100%; height: 100%; background: #00ff00; transition: width 0.1s, background 0.2s;
        }
        #health-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 16px; color: white; z-index: 2;
        }

        #boss-label {
            color: red; font-size: 30px; display: none; animation: pulse 1s infinite;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid #00ff00; border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #weapon-bar {
            padding: 20px; color: white; font-size: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
        }

        /* RED FLASH ON DAMAGE */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s;
        }

        /* MENUS */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 10; pointer-events: auto;
        }
        h1 { font-size: 60px; margin: 0; color: #ff3333; text-shadow: 0 0 20px #ff0000; }
        button {
            padding: 15px 50px; font-size: 24px; margin-top: 30px; cursor: pointer;
            background: #ff3333; color: white; border: none; font-weight: bold;
            box-shadow: 0 0 15px #ff0000;
        }
        button:hover { background: white; color: red; }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>

    <div id="hud">
        <div id="top-bar">
            <div id="wave-info">WAVE 1</div>
            <div id="boss-label">⚠ BOSS FIGHT ⚠</div>
            <div id="health-container">
                <div id="health-fill"></div>
                <div id="health-text">100%</div>
            </div>
        </div>
        <div id="crosshair"></div>
        <div id="weapon-bar">
            1: RIFLE | 2: PISTOL | 3: GRENADE <br>
            <span id="current-weapon" style="color: #00ff00">EQUIPPED: RIFLE</span>
        </div>
    </div>

    <div id="menu-overlay">
        <h1>SURVIVAL ARENA</h1>
        <p>Bosses every 5 waves. Do not get hit.</p>
        <button id="start-btn">START GAME</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONSTANTS ---
        const PLAYER_SPEED = 14.0;
        const MAX_HEALTH = 100;
        
        // --- GLOBALS ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Game State
        let wave = 1;
        let playerHealth = MAX_HEALTH;
        let isGameOver = false;
        let enemiesRemaining = 0;
        let isBossWave = false;

        // Arrays
        const bullets = [];
        const enemies = [];
        const grenades = [];
        let weaponMeshes = {};
        
        // Weapons
        let currentWeapon = 1;
        let lastShotTime = 0;
        let isMouseDown = false;
        
        const weapons = {
            1: { name: "PLASMA RIFLE", delay: 90, auto: true, speed: 220, color: 0x00ffff, damage: 4 },
            2: { name: "MAGNUM PISTOL", delay: 300, auto: false, speed: 150, color: 0xffaa00, damage: 15 },
            3: { name: "FRAG GRENADE", delay: 1500, auto: false, speed: 35, color: 0x00ff00, damage: 80 }
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 10, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Lighting
            const amb = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(0, 50, 0);
            scene.add(dir);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            const menu = document.getElementById('menu-overlay');
            const startBtn = document.getElementById('start-btn');

            startBtn.addEventListener('click', () => {
                controls.lock();
            });

            controls.addEventListener('lock', () => {
                menu.style.display = 'none';
                if (isGameOver) resetGame();
            });
            
            controls.addEventListener('unlock', () => {
                if (!isGameOver) {
                    menu.style.display = 'flex';
                    document.querySelector('#menu-overlay h1').innerText = "PAUSED";
                    startBtn.innerText = "RESUME";
                }
            });

            scene.add(controls.getObject());

            buildMap();
            buildWeapons();
            switchWeapon(1);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', () => { isMouseDown = true; checkShoot(); });
            document.addEventListener('mouseup', () => isMouseDown = false);
            window.addEventListener('resize', onWindowResize);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Start Logic
            resetGame();
        }

        function resetGame() {
            isGameOver = false;
            playerHealth = MAX_HEALTH;
            updateHealthUI();
            wave = 0;
            
            // Clear enemies
            for(let e of enemies) scene.remove(e);
            enemies.length = 0;
            
            startNextWave();
        }

        function startNextWave() {
            wave++;
            document.getElementById('wave-info').innerText = "WAVE " + wave;
            
            // Boss Check: Every 5 waves (5, 10, 15...)
            isBossWave = (wave % 5 === 0);
            const bossLabel = document.getElementById('boss-label');
            
            if (isBossWave) {
                bossLabel.style.display = 'block';
                enemiesRemaining = 1; // Just the boss (minions can spawn from logic if desired)
                spawnBoss();
            } else {
                bossLabel.style.display = 'none';
                // Difficulty scaling
                let count = 5 + Math.floor(wave * 1.5);
                enemiesRemaining = count;
                for(let i=0; i<count; i++) spawnEnemy();
            }
        }

        function spawnEnemy() {
            const group = new THREE.Group();
            // Drone Body
            const geo = new THREE.OctahedronGeometry(0.8);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.2, metalness: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Glowing Eye
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            eye.position.z = 0.5;

            group.add(mesh, eye);
            
            // Random Spawn Pos
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 30;
            group.position.set(Math.cos(angle)*dist, 2, Math.sin(angle)*dist);

            group.userData = { hp: 15 + (wave * 2), speed: 6 + (wave * 0.2), isBoss: false, damage: 10 };
            scene.add(group);
            enemies.push(group);
        }

        function spawnBoss() {
            const group = new THREE.Group();
            
            // Massive Body
            const geo = new THREE.BoxGeometry(4, 6, 4);
            const mat = new THREE.MeshStandardMaterial({ color: 0x220000 });
            const body = new THREE.Mesh(geo, mat);
            
            // Armor Plates
            const plate = new THREE.Mesh(new THREE.BoxGeometry(4.2, 3, 4.2), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9 }));
            plate.position.y = 1;

            // Giant Eye
            const eye = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            eye.position.set(0, 1.5, 2);

            group.add(body, plate, eye);
            group.position.set(0, 3, -60);

            // Boss HP Calculation: 200 base + 100 per boss wave index
            const bossIndex = wave / 5;
            const hp = 200 + (bossIndex * 150);

            group.userData = { 
                hp: hp, 
                maxHp: hp, 
                speed: 9, // Bosses are fast
                isBoss: true, 
                damage: 35 // Hits hard
            };
            
            scene.add(group);
            enemies.push(group);
        }

        function damagePlayer(amount) {
            if (isGameOver) return;

            playerHealth -= amount;
            
            // Red Flash
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.5;
            setTimeout(() => overlay.style.opacity = 0, 100);

            if (playerHealth <= 0) {
                playerHealth = 0;
                gameOver();
            }
            updateHealthUI();
        }

        function updateHealthUI() {
            const fill = document.getElementById('health-fill');
            const text = document.getElementById('health-text');
            
            fill.style.width = playerHealth + "%";
            text.innerText = playerHealth + "%";

            if (playerHealth > 50) fill.style.background = "#00ff00";
            else if (playerHealth > 25) fill.style.background = "#ffff00";
            else fill.style.background = "#ff0000";
        }

        function gameOver() {
            isGameOver = true;
            controls.unlock();
            document.getElementById('menu-overlay').style.display = 'flex';
            document.querySelector('#menu-overlay h1').innerText = "GAME OVER";
            document.getElementById('start-btn').innerText = "RESTART";
        }

        // --- WEAPON & COMBAT ---

        function checkShoot() {
            const now = performance.now();
            const w = weapons[currentWeapon];
            if (now - lastShotTime > w.delay) {
                lastShotTime = now;
                if (currentWeapon === 3) throwGrenade(w);
                else fireBullet(w);
            }
        }

        function fireBullet(w) {
            weaponMeshes[currentWeapon].position.z += 0.2; // Recoil

            const geo = new THREE.SphereGeometry(0.1);
            const mat = new THREE.MeshBasicMaterial({ color: w.color });
            const b = new THREE.Mesh(geo, mat);

            b.position.copy(camera.position);
            const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            b.position.add(right.multiplyScalar(0.2));
            b.position.y -= 0.2;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            b.userData = { vel: dir.multiplyScalar(w.speed), dmg: w.damage };
            
            scene.add(b);
            bullets.push(b);
        }

        function throwGrenade(w) {
            weaponMeshes[3].visible = false;
            setTimeout(() => { if(currentWeapon===3) weaponMeshes[3].visible=true; }, 1000);

            const g = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.3), new THREE.MeshStandardMaterial({color:0x00ff00}));
            g.position.copy(camera.position);
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const vel = dir.multiplyScalar(25);
            vel.y += 10;
            
            g.userData = { vel: vel, timer: 100, dmg: w.damage };
            scene.add(g);
            grenades.push(g);
        }

        function createExplosion(pos, dmg) {
            const exp = new THREE.Mesh(new THREE.SphereGeometry(8), new THREE.MeshBasicMaterial({color:0xffaa00, transparent:true, opacity:0.8}));
            exp.position.copy(pos);
            scene.add(exp);
            setTimeout(()=>scene.remove(exp), 150);

            for(let i=enemies.length-1; i>=0; i--) {
                if(enemies[i].position.distanceTo(pos) < 10) hitEnemy(i, dmg);
            }
        }

        function hitEnemy(idx, dmg) {
            const e = enemies[idx];
            e.userData.hp -= dmg;
            
            // Flash
            e.children.forEach(c => {
                if(c.material) {
                    c.material.emissive = new THREE.Color(0xffffff);
                    setTimeout(()=> { if(c && c.material) c.material.emissive = new THREE.Color(0x000000); }, 50);
                }
            });

            if(e.userData.hp <= 0) {
                scene.remove(e);
                enemies.splice(idx, 1);
                enemiesRemaining--;
                if(enemiesRemaining <= 0) setTimeout(startNextWave, 2000);
            }
        }

        // --- MOVEMENT & LOOP ---

        function animate() {
            requestAnimationFrame(animate);
            if(isGameOver) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 600.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 600.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                if(controls.getObject().position.y < 2) {
                    controls.getObject().position.y = 2;
                    velocity.y = 0;
                }
                
                // Keep player in bounds
                const pPos = controls.getObject().position;
                pPos.x = Math.max(-95, Math.min(95, pPos.x));
                pPos.z = Math.max(-95, Math.min(95, pPos.z));

                // Weapon Recoil Return
                const wm = weaponMeshes[currentWeapon];
                if(wm && wm.position.z > -0.6) wm.position.z -= 1 * delta;

                if(isMouseDown && weapons[currentWeapon].auto) checkShoot();

                // Entity Updates
                updateBullets(delta);
                updateGrenades(delta);
                updateEnemies(delta);
            }

            renderer.render(scene, camera);
        }

        function updateEnemies(delta) {
            const playerPos = controls.getObject().position;
            
            for(let i=0; i<enemies.length; i++) {
                const e = enemies[i];
                const dist = e.position.distanceTo(playerPos);
                
                // Move towards player
                if(dist > 2) {
                    const dir = new THREE.Vector3().subVectors(playerPos, e.position).normalize();
                    dir.y = 0;
                    e.position.add(dir.multiplyScalar(e.userData.speed * delta));
                    e.lookAt(playerPos);
                }

                // Check Damage Collision (Simple DPS check)
                if(dist < 2.5) {
                    damagePlayer(e.userData.damage * delta * 5); // Damage over time if touching
                    
                    // Push enemy back slightly so they don't clip inside you
                    const push = new THREE.Vector3().subVectors(e.position, playerPos).normalize();
                    e.position.add(push.multiplyScalar(0.1));
                }
            }
        }

        function updateBullets(delta) {
            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.vel.clone().multiplyScalar(delta));
                
                if(b.position.distanceTo(camera.position) > 200) {
                    scene.remove(b); bullets.splice(i,1); continue;
                }

                for(let j=enemies.length-1; j>=0; j--) {
                    const e = enemies[j];
                    const hitSize = e.userData.isBoss ? 4 : 1.5;
                    if(b.position.distanceTo(e.position) < hitSize) {
                        hitEnemy(j, b.userData.dmg);
                        scene.remove(b); bullets.splice(i,1); break;
                    }
                }
            }
        }

        function updateGrenades(delta) {
            for(let i=grenades.length-1; i>=0; i--) {
                const g = grenades[i];
                g.userData.vel.y -= 50 * delta;
                g.position.add(g.userData.vel.clone().multiplyScalar(delta));
                
                if(g.position.y < 0.5) {
                    g.position.y = 0.5;
                    g.userData.vel.y *= -0.5;
                    g.userData.vel.x *= 0.6;
                    g.userData.vel.z *= 0.6;
                }
                
                g.userData.timer--;
                if(g.userData.timer <= 0) {
                    createExplosion(g.position, g.userData.dmg);
                    scene.remove(g); grenades.splice(i,1);
                }
            }
        }

        // --- SETUP HELPERS ---
        function buildMap() {
            // Floor
            const f = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x111111}));
            f.rotation.x = -Math.PI/2;
            scene.add(f);
            scene.add(new THREE.GridHelper(200, 40, 0x444444, 0x222222));
            
            // Pillars
            const geo = new THREE.BoxGeometry(10,20,10);
            const mat = new THREE.MeshStandardMaterial({color:0x333333});
            [[40,40],[-40,40],[40,-40],[-40,-40]].forEach(p=>{
                const m = new THREE.Mesh(geo, mat);
                m.position.set(p[0], 10, p[1]);
                scene.add(m);
            });
        }

        function buildWeapons() {
            // Rifle
            const r = new THREE.Group();
            r.add(new THREE.Mesh(new THREE.BoxGeometry(0.1,0.2,0.8), new THREE.MeshStandardMaterial({color:0x444444})));
            r.position.set(0.4,-0.4,-0.6);
            camera.add(r); weaponMeshes[1] = r;

            // Pistol
            const p = new THREE.Group();
            p.add(new THREE.Mesh(new THREE.BoxGeometry(0.1,0.15,0.4), new THREE.MeshStandardMaterial({color:0x888888})));
            p.position.set(0.4,-0.4,-0.6); p.visible=false;
            camera.add(p); weaponMeshes[2] = p;

            // Grenade
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({color:0x00ff00})));
            g.position.set(0.4,-0.4,-0.6); g.visible=false;
            camera.add(g); weaponMeshes[3] = g;
        }

        function switchWeapon(id) {
            currentWeapon = id;
            for(let k in weaponMeshes) weaponMeshes[k].visible = false;
            weaponMeshes[id].visible = true;
            document.getElementById('current-weapon').innerText = "EQUIPPED: " + weapons[id].name;
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward=true; break;
                case 'KeyS': moveBackward=true; break;
                case 'KeyA': moveLeft=true; break;
                case 'KeyD': moveRight=true; break;
                case 'Digit1': switchWeapon(1); break;
                case 'Digit2': switchWeapon(2); break;
                case 'Digit3': switchWeapon(3); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward=false; break;
                case 'KeyS': moveBackward=false; break;
                case 'KeyA': moveLeft=false; break;
                case 'KeyD': moveRight=false; break;
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
