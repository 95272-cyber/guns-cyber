<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced JS FPS</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        #hud-bottom {
            padding: 20px;
            color: #0f0;
            text-shadow: 1px 1px 0 #000;
            font-size: 24px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        }

        #instructions {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.8); 
            padding: 20px; text-align: center; border: 1px solid #444;
            pointer-events: auto; cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="hud-bottom">
            <div id="weapon-name">WEAPON: ASSAULT RIFLE</div>
            <div>CONTROLS: WASD to Move | Click to Shoot | 1, 2, 3 to Switch Weapons</div>
        </div>
    </div>

    <div id="instructions">
        <h1>FPS PROTOTYPE V2</h1>
        <p>Click here to Start</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Game State
        const bullets = [];
        const grenades = [];
        const enemies = [];
        let lastShotTime = 0;
        let enemySpawnTimer = 0;

        // Weapon System
        let currentWeaponIdx = 0; // 0: Rifle, 1: Pistol, 2: Grenade
        let weaponModels = [];
        
        const weapons = [
            { name: "ASSAULT RIFLE", fireRate: 100, speed: 200, color: 0xffff00, size: 0.2 },
            { name: "PISTOL", fireRate: 400, speed: 150, color: 0xffaa00, size: 0.2 },
            { name: "GRENADE", fireRate: 1000, speed: 30, color: 0x00ff00, size: 0.5 }
        ];

        init();
        animate();

        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 0, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // 2. Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // 3. Controls
            controls = new PointerLockControls(camera, document.body);
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => instructions.style.display = 'none');
            controls.addEventListener('unlock', () => instructions.style.display = 'block');
            scene.add(controls.getObject());

            // 4. Build World
            buildWorld();

            // 5. Build Weapons
            buildWeapons();

            // 6. Events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            // 7. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        // --- BUILDING OBJECTS ---

        function buildWorld() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            floorGeo.rotateX(-Math.PI / 2);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            scene.add(floor);

            // Random Obstacles
            const boxGeo = new THREE.BoxGeometry(4, 4, 4);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            for(let i=0; i<20; i++) {
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.set(
                    (Math.random() - 0.5) * 100,
                    2,
                    (Math.random() - 0.5) * 100
                );
                scene.add(box);
            }
        }

        function buildWeapons() {
            // -- 1. Rifle Model --
            const rifleGroup = new THREE.Group();
            
            // Stock
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            stock.position.z = 0.4;
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 1.0), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            // Barrel
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.2), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -0.8;
            // Scope
            const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.4), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            scope.rotation.x = Math.PI / 2;
            scope.position.y = 0.2;
            // Mag
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.2), new THREE.MeshStandardMaterial({ color: 0x555555 }));
            mag.position.y = -0.3;
            mag.position.z = -0.1;

            rifleGroup.add(stock, body, barrel, scope, mag);
            rifleGroup.position.set(0.5, -0.5, -1);
            camera.add(rifleGroup);
            weaponModels.push(rifleGroup);

            // -- 2. Pistol Model --
            const pistolGroup = new THREE.Group();
            const pBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.6), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            const pHandle = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            pHandle.position.set(0, -0.3, 0.2);
            pHandle.rotation.x = -0.2;
            
            pistolGroup.add(pBody, pHandle);
            pistolGroup.position.set(0.5, -0.6, -0.8);
            pistolGroup.visible = false;
            camera.add(pistolGroup);
            weaponModels.push(pistolGroup);

            // -- 3. Grenade Hand --
            const grenadeGroup = new THREE.Group();
            const gBody = new THREE.Mesh(new THREE.IcosahedronGeometry(0.15, 1), new THREE.MeshStandardMaterial({ color: 0x228b22 }));
            grenadeGroup.add(gBody);
            grenadeGroup.position.set(0.5, -0.6, -0.8);
            grenadeGroup.visible = false;
            camera.add(grenadeGroup);
            weaponModels.push(grenadeGroup);
        }

        function spawnEnemy() {
            // Spawn a red cube enemy
            const geo = new THREE.BoxGeometry(1.5, 3, 1.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const enemy = new THREE.Mesh(geo, mat);
            
            // Random position away from player
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 20;
            enemy.position.x = controls.getObject().position.x + Math.cos(angle) * radius;
            enemy.position.z = controls.getObject().position.z + Math.sin(angle) * radius;
            enemy.position.y = 1.5;

            scene.add(enemy);
            enemies.push(enemy);
        }

        // --- GAMEPLAY LOGIC ---

        function onMouseDown() {
            if (!controls.isLocked) return;

            const now = performance.now();
            const weaponData = weapons[currentWeaponIdx];

            if (now - lastShotTime > weaponData.fireRate) {
                lastShotTime = now;
                
                if (currentWeaponIdx === 2) {
                    throwGrenade();
                } else {
                    shootBullet(weaponData);
                    // Visual recoil
                    weaponModels[currentWeaponIdx].position.z += 0.2; 
                }
            }
        }

        function shootBullet(stats) {
            const geo = new THREE.SphereGeometry(0.1, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: stats.color });
            const bullet = new THREE.Mesh(geo, mat);

            // Start at gun position
            bullet.position.copy(controls.getObject().position);
            bullet.position.y -= 0.5; // lower slightly
            
            // Get direction camera is facing
            const dir = new THREE.Vector3();
            controls.getDirection(dir);
            
            // Move bullet slightly forward so it doesn't clip player
            bullet.position.add(dir.clone().multiplyScalar(1));

            bullet.userData = { velocity: dir.multiplyScalar(stats.speed) };
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        function throwGrenade() {
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const gren = new THREE.Mesh(geo, mat);

            gren.position.copy(controls.getObject().position);
            
            const dir = new THREE.Vector3();
            controls.getDirection(dir);

            // Throw arc: Forward + Up
            const velocity = dir.multiplyScalar(25);
            velocity.y += 10; 

            gren.userData = { 
                velocity: velocity,
                timer: 2000 // 2 seconds to explode
            };

            scene.add(gren);
            grenades.push(gren);
        }

        function explodeGrenade(grenade) {
            // Visual explosion
            const particleGeo = new THREE.SphereGeometry(0.1);
            const particleMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            
            // Create simple explosion particles
            for(let i=0; i<10; i++) {
                // Simplified particle effect for performance
            }

            // Damage Logic: Check distance to all enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.position.distanceTo(grenade.position) < 15) {
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }

            scene.remove(grenade);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Digit1': switchWeapon(0); break;
                case 'Digit2': switchWeapon(1); break;
                case 'Digit3': switchWeapon(2); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function switchWeapon(idx) {
            currentWeaponIdx = idx;
            document.getElementById('weapon-name').innerText = "WEAPON: " + weapons[idx].name;
            
            // Hide all, show current
            weaponModels.forEach((model, i) => {
                model.visible = (i === idx);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // 1. Player Movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // 2. Weapon Recoil Recovery
                const currentModel = weaponModels[currentWeaponIdx];
                if (currentModel) {
                    const baseZ = (currentWeaponIdx === 0) ? -1 : -0.8;
                    if (currentModel.position.z > baseZ) {
                        currentModel.position.z -= 2 * delta;
                    }
                }

                // 3. Update Bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.position.add(b.userData.velocity.clone().multiplyScalar(delta));

                    // Simple collision with enemies (Distance check)
                    let hit = false;
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (b.position.distanceTo(enemies[j].position) < 2) {
                            scene.remove(enemies[j]);
                            enemies.splice(j, 1);
                            hit = true;
                            break;
                        }
                    }

                    // Remove if hit or too far
                    if (hit || b.position.distanceTo(controls.getObject().position) > 100) {
                        scene.remove(b);
                        bullets.splice(i, 1);
                    }
                }

                // 4. Update Grenades
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const g = grenades[i];
                    g.userData.velocity.y -= 50 * delta; // Gravity
                    g.position.add(g.userData.velocity.clone().multiplyScalar(delta));

                    // Floor collision
                    if (g.position.y < 0.5) {
                        g.position.y = 0.5;
                        g.userData.velocity.x *= 0.8; // friction
                        g.userData.velocity.z *= 0.8;
                    }

                    g.userData.timer -= delta * 1000;
                    if (g.userData.timer <= 0) {
                        explodeGrenade(g);
                        grenades.splice(i, 1);
                    }
                }

                // 5. Update Enemies (Chase Player)
                enemySpawnTimer += delta;
                if (enemySpawnTimer > 3) { // Spawn every 3 seconds
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }

                const playerPos = controls.getObject().position;
                enemies.forEach(enemy => {
                    const dir = new THREE.Vector3().subVectors(playerPos, enemy.position).normalize();
                    // Ignore Y difference for movement (enemies stay on ground)
                    dir.y = 0; 
                    enemy.position.add(dir.multiplyScalar(4 * delta));
                    enemy.lookAt(playerPos);
                });
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
