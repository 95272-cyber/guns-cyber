<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fixed FPS Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: Arial, sans-serif; user-select: none; }
        
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid #0f0; border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px #0f0;
        }

        #ammo-panel {
            position: absolute; bottom: 20px; right: 20px;
            color: #0f0; font-size: 30px; font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #weapon-panel {
            position: absolute; bottom: 20px; left: 20px;
            color: white; font-size: 24px;
            text-shadow: 2px 2px 0 #000;
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            color: white; flex-direction: column; pointer-events: auto;
        }
    </style>
</head>
<body>

    <div id="hud">
        <div id="crosshair"></div>
        <div id="weapon-panel">Current: 1 - ASSAULT RIFLE</div>
        <div id="ammo-panel">âˆž</div>
    </div>

    <div id="overlay">
        <h1>FPS UPDATE</h1>
        <p>Click to Start</p>
        <p>1: Rifle | 2: Pistol | 3: Grenade</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isMouseDown = false;
        
        // Game Objects
        const bullets = [];
        const grenades = [];
        const enemies = [];
        const explosions = [];
        let weaponMeshes = [];

        // Weapon Stats
        let currentWeapon = 1; // 1, 2, or 3
        let lastShotTime = 0;
        
        // 1: Rifle (Fast, Auto) | 2: Pistol (Slow, Semi) | 3: Grenade
        const weapons = {
            1: { name: "ASSAULT RIFLE", delay: 100, auto: true, speed: 150, color: 0xffff00 },
            2: { name: "PISTOL", delay: 300, auto: false, speed: 100, color: 0xffaa00 },
            3: { name: "GRENADE", delay: 1000, auto: false, speed: 25, color: 0x00ff00 }
        };

        // Physics
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 0, 80);

            // 2. Setup Camera (Low 'near' value prevents hollow gun clipping)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 1000);

            // 3. Lighting
            const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // 4. Input Controls
            controls = new PointerLockControls(camera, document.body);
            const overlay = document.getElementById('overlay');
            
            overlay.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => overlay.style.display = 'none');
            controls.addEventListener('unlock', () => overlay.style.display = 'flex');
            
            scene.add(controls.getObject());

            // 5. Build Environment
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            floorGeo.rotateX(-Math.PI / 2);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            scene.add(floor);

            // 6. Build Weapons
            buildWeapons();
            switchWeapon(1);

            // 7. Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', () => { isMouseDown = true; checkShoot(); });
            document.addEventListener('mouseup', () => isMouseDown = false);
            window.addEventListener('resize', onWindowResize);

            // 8. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Spawn initial enemies
            for(let i=0; i<5; i++) spawnEnemy();
        }

        function buildWeapons() {
            // --- Rifle (1) ---
            const rifleGroup = new THREE.Group();
            // Solid Back
            const rStock = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.4), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            rStock.position.set(0, -0.05, 0.3);
            // Main Body
            const rBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            // Barrel
            const rBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.8), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            rBarrel.rotation.x = Math.PI / 2;
            rBarrel.position.set(0, 0.05, -0.6);
            
            rifleGroup.add(rStock, rBody, rBarrel);
            rifleGroup.position.set(0.3, -0.3, -0.5);
            camera.add(rifleGroup);
            weaponMeshes[1] = rifleGroup;

            // --- Pistol (2) ---
            const pistolGroup = new THREE.Group();
            const pBody = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0x666666 }));
            const pBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            pBarrel.rotation.x = Math.PI / 2;
            pBarrel.position.z = -0.2;
            
            pistolGroup.add(pBody, pBarrel);
            pistolGroup.position.set(0.3, -0.3, -0.4);
            pistolGroup.visible = false;
            camera.add(pistolGroup);
            weaponMeshes[2] = pistolGroup;

            // --- Grenade (3) ---
            const grenGroup = new THREE.Group();
            const gBody = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
            grenGroup.add(gBody);
            grenGroup.position.set(0.3, -0.3, -0.4);
            grenGroup.visible = false;
            camera.add(grenGroup);
            weaponMeshes[3] = grenGroup;
        }

        function switchWeapon(id) {
            currentWeapon = id;
            // Hide all
            for(let key in weaponMeshes) weaponMeshes[key].visible = false;
            // Show selected
            weaponMeshes[id].visible = true;
            
            document.getElementById('weapon-panel').innerText = "Current: " + id + " - " + weapons[id].name;
        }

        function spawnEnemy() {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const enemy = new THREE.Mesh(geo, mat);
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            enemy.position.set(Math.cos(angle)*dist, 1, Math.sin(angle)*dist);
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function checkShoot() {
            const now = performance.now();
            const w = weapons[currentWeapon];

            if (now - lastShotTime > w.delay) {
                lastShotTime = now;

                if (currentWeapon === 3) {
                    throwGrenade();
                } else {
                    fireBullet(w);
                }
            }
        }

        function fireBullet(w) {
            // Visual Recoil
            weaponMeshes[currentWeapon].position.z += 0.1;

            const geo = new THREE.SphereGeometry(0.05);
            const mat = new THREE.MeshBasicMaterial({ color: w.color });
            const bullet = new THREE.Mesh(geo, mat);

            // Start at gun position
            bullet.position.copy(camera.position); // Start at head
            // Offset slightly to right
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            bullet.position.add(right.multiplyScalar(0.2));
            bullet.position.y -= 0.2;

            // Direction
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            bullet.userData = { velocity: dir.multiplyScalar(w.speed) };

            scene.add(bullet);
            bullets.push(bullet);
        }

        function throwGrenade() {
            // Hide hand model briefly
            weaponMeshes[3].visible = false;
            setTimeout(() => { if(currentWeapon===3) weaponMeshes[3].visible = true; }, 500);

            const geo = new THREE.SphereGeometry(0.2);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const gren = new THREE.Mesh(geo, mat);

            gren.position.copy(camera.position);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            
            // Throw forward and up
            const vel = dir.multiplyScalar(20);
            vel.y += 10;
            
            gren.userData = { velocity: vel, timer: 100 }; // frames until explode

            scene.add(gren);
            grenades.push(gren);
        }

        function createExplosion(pos) {
            // Visual
            const geo = new THREE.SphereGeometry(4);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 });
            const exp = new THREE.Mesh(geo, mat);
            exp.position.copy(pos);
            scene.add(exp);
            
            // Logic: Kill nearby enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (enemies[i].position.distanceTo(pos) < 8) {
                    scene.remove(enemies[i]);
                    enemies.splice(i, 1);
                    spawnEnemy(); // Respawn
                }
            }

            // Remove visual after a bit
            setTimeout(() => scene.remove(exp), 200);
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Digit1': switchWeapon(1); break;
                case 'Digit2': switchWeapon(2); break;
                case 'Digit3': switchWeapon(3); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // Movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y = 2; // Keep on ground

                // Recoil Recovery
                const wMesh = weaponMeshes[currentWeapon];
                if(wMesh && wMesh.position.z > (currentWeapon===1 ? -0.5 : -0.4)) {
                    wMesh.position.z -= 1 * delta;
                }

                // Auto Fire for Rifle
                if (isMouseDown && weapons[currentWeapon].auto) {
                    checkShoot();
                }

                // Bullet Logic
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
                    
                    // Cleanup distance
                    if (b.position.distanceTo(camera.position) > 100) {
                        scene.remove(b);
                        bullets.splice(i, 1);
                        continue;
                    }

                    // Hit Enemy
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (b.position.distanceTo(enemies[j].position) < 2) {
                            scene.remove(enemies[j]);
                            enemies.splice(j, 1);
                            scene.remove(b);
                            bullets.splice(i, 1);
                            spawnEnemy(); // Keep game going
                            break;
                        }
                    }
                }

                // Grenade Logic
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const g = grenades[i];
                    g.userData.velocity.y -= 50 * delta; // Gravity
                    g.position.add(g.userData.velocity.clone().multiplyScalar(delta));

                    // Bounce Floor
                    if(g.position.y < 0.5) {
                        g.position.y = 0.5;
                        g.userData.velocity.y *= -0.5;
                        g.userData.velocity.x *= 0.7;
                        g.userData.velocity.z *= 0.7;
                    }

                    g.userData.timer--;
                    if(g.userData.timer <= 0) {
                        createExplosion(g.position);
                        scene.remove(g);
                        grenades.splice(i, 1);
                    }
                }

                // Enemy AI (Chase)
                enemies.forEach(e => {
                    const dir = new THREE.Vector3().subVectors(camera.position, e.position);
                    dir.y = 0;
                    dir.normalize();
                    e.position.add(dir.multiplyScalar(4 * delta));
                    e.lookAt(camera.position);
                });
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
