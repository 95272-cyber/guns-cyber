<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sci-Fi Arena Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* HUD ELEMENTS */
        #hud-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        #top-bar {
            display: flex; justify-content: space-between; padding: 20px;
            font-size: 24px; font-weight: bold; color: white; text-shadow: 0 0 5px #000;
        }

        #wave-indicator { color: #00ffff; }
        #enemy-count { color: #ff5555; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 24px; height: 24px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="lime" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="6" x2="12" y2="18"/><line x1="6" y1="12" x2="18" y2="12"/></svg>');
            transform: translate(-50%, -50%);
        }

        #bottom-bar {
            padding: 20px; display: flex; justify-content: space-between; align-items: flex-end;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        }

        #weapon-info { color: #fff; font-size: 20px; }
        .key { display: inline-block; padding: 5px 10px; border: 1px solid #fff; border-radius: 4px; margin-right: 5px; font-size: 14px; }

        #boss-bar-container {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 20px; background: #333; border: 2px solid white;
            display: none; /* Hidden until boss wave */
        }
        #boss-health-fill {
            width: 100%; height: 100%; background: #ff0000; transition: width 0.1s;
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            color: white; pointer-events: auto; z-index: 10;
        }
        button {
            padding: 15px 40px; font-size: 20px; cursor: pointer;
            background: #00ffff; border: none; font-weight: bold; margin-top: 20px;
            box-shadow: 0 0 10px #00ffff;
        }
        button:hover { background: #fff; }

    </style>
</head>
<body>

    <div id="hud-container">
        <div id="top-bar">
            <div id="wave-indicator">WAVE 1</div>
            <div id="boss-bar-container"><div id="boss-health-fill"></div></div>
            <div id="enemy-count">ENEMIES: 0</div>
        </div>
        <div id="crosshair"></div>
        <div id="bottom-bar">
            <div id="weapon-info">
                <span class="key">1</span> Rifle 
                <span class="key">2</span> Pistol 
                <span class="key">3</span> Grenade
                <br><br>
                <div id="current-weapon-name" style="color:#00ff00; font-weight:bold;">EQUIPPED: ASSAULT RIFLE</div>
            </div>
        </div>
    </div>

    <div id="overlay">
        <h1 style="font-size: 50px; text-shadow: 0 0 20px #00ffff;">HYPER SHOOTER</h1>
        <p>Defeat 3 Waves. Kill the Boss.</p>
        <p>WASD to Move | Click to Shoot</p>
        <button id="start-btn">START SIMULATION</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIG ---
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_SPEED = 12.0;
        
        // --- GLOBALS ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isMouseDown = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Game State
        let wave = 1;
        let enemiesRemaining = 0;
        let gameActive = false;
        let bossActive = false;
        
        // Arrays
        const bullets = [];
        const enemies = [];
        const grenades = [];
        const particles = [];
        let weaponMeshes = {};

        // Weapon Data
        let currentWeapon = 1; 
        let lastShotTime = 0;
        const weapons = {
            1: { name: "PLASMA RIFLE", delay: 100, auto: true, speed: 200, color: 0x00ffff, damage: 1 },
            2: { name: "HEAVY PISTOL", delay: 250, auto: false, speed: 120, color: 0xffaa00, damage: 2 },
            3: { name: "FRAG GRENADE", delay: 1200, auto: false, speed: 30, color: 0x00ff00, damage: 10 }
        };

        // UI Elements
        const waveText = document.getElementById('wave-indicator');
        const enemyText = document.getElementById('enemy-count');
        const weaponText = document.getElementById('current-weapon-name');
        const bossBar = document.getElementById('boss-bar-container');
        const bossFill = document.getElementById('boss-health-fill');

        init();
        animate();

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x88ccff); // Sky color
            scene.fog = new THREE.Fog(0x88ccff, 20, 150);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => {
                controls.lock();
                if(!gameActive) startGame();
            });

            controls.addEventListener('lock', () => document.getElementById('overlay').style.display = 'none');
            controls.addEventListener('unlock', () => document.getElementById('overlay').style.display = 'flex');

            scene.add(controls.getObject());

            // --- BUILD MAP ---
            buildMap();

            // --- BUILD WEAPONS ---
            buildWeapons();
            switchWeapon(1);

            // Input Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', () => { isMouseDown = true; checkShoot(); });
            document.addEventListener('mouseup', () => isMouseDown = false);
            window.addEventListener('resize', onWindowResize);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
        }

        function buildMap() {
            // 1. Floor (Grid)
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            floorGeo.rotateX(-Math.PI / 2);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.5,
                metalness: 0.5
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            scene.add(floor);

            // Grid Helper
            const grid = new THREE.GridHelper(200, 50, 0x00ffff, 0x333333);
            scene.add(grid);

            // 2. Pillars/Obstacles
            const pillarGeo = new THREE.BoxGeometry(5, 10, 5);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            
            // Create 4 symmetrical pillars
            const positions = [[20, 20], [-20, 20], [20, -20], [-20, -20]];
            positions.forEach(pos => {
                const p = new THREE.Mesh(pillarGeo, pillarMat);
                p.position.set(pos[0], 5, pos[1]);
                scene.add(p);
                
                // Add glowing trim
                const trim = new THREE.Mesh(new THREE.BoxGeometry(5.2, 0.5, 5.2), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                trim.position.set(pos[0], 2, pos[1]);
                scene.add(trim);
            });

            // 3. Walls
            const wallH = new THREE.BoxGeometry(200, 20, 2);
            const wallV = new THREE.BoxGeometry(2, 20, 200);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            const w1 = new THREE.Mesh(wallH, wallMat); w1.position.z = -100; w1.position.y=10;
            const w2 = new THREE.Mesh(wallH, wallMat); w2.position.z = 100; w2.position.y=10;
            const w3 = new THREE.Mesh(wallV, wallMat); w3.position.x = -100; w3.position.y=10;
            const w4 = new THREE.Mesh(wallV, wallMat); w4.position.x = 100; w4.position.y=10;
            scene.add(w1, w2, w3, w4);
        }

        function buildWeapons() {
            // --- 1. RIFLE MODEL ---
            const rGroup = new THREE.Group();
            
            // Main Chassis
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.6), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            
            // Scope
            const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            scope.rotation.x = Math.PI / 2;
            scope.position.y = 0.12;

            // Barrel with glowing tip
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -0.4;
            
            // Mag
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x555555 }));
            mag.position.set(0, -0.15, 0.1);

            rGroup.add(body, scope, barrel, mag);
            rGroup.position.set(0.4, -0.4, -0.6);
            camera.add(rGroup);
            weaponMeshes[1] = rGroup;

            // --- 2. PISTOL MODEL ---
            const pGroup = new THREE.Group();
            const pSlide = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.3), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            const pGrip = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.2, 0.1), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            pGrip.position.set(0, -0.1, 0.05);
            pGrip.rotation.x = 0.2;
            
            pGroup.add(pSlide, pGrip);
            pGroup.position.set(0.4, -0.4, -0.5);
            pGroup.visible = false;
            camera.add(pGroup);
            weaponMeshes[2] = pGroup;

            // --- 3. GRENADE MODEL ---
            const gGroup = new THREE.Group();
            const gCan = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.2), new THREE.MeshStandardMaterial({ color: 0x00aa00 }));
            const gCap = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.05), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            gCap.position.y = 0.12;
            
            gGroup.add(gCan, gCap);
            gGroup.rotation.x = Math.PI / 4;
            gGroup.position.set(0.4, -0.4, -0.5);
            gGroup.visible = false;
            camera.add(gGroup);
            weaponMeshes[3] = gGroup;
        }

        // --- GAME LOGIC ---

        function startGame() {
            gameActive = true;
            wave = 0; // Will increment to 1 immediately
            startNextWave();
        }

        function startNextWave() {
            wave++;
            waveText.innerText = "WAVE " + wave;
            
            let enemyCount = 0;
            if (wave === 1) enemyCount = 5;
            else if (wave === 2) enemyCount = 10;
            else if (wave === 3) {
                enemyCount = 1; // The Boss
                bossActive = true;
                waveText.innerText = "BOSS BATTLE";
                waveText.style.color = "red";
                bossBar.style.display = "block";
                bossFill.style.width = "100%";
            } else {
                // Infinite scaling waves after boss
                enemyCount = wave * 2;
                bossActive = false;
                bossBar.style.display = "none";
            }

            enemiesRemaining = enemyCount;
            updateEnemyCounter();

            for(let i=0; i<enemyCount; i++) {
                if(wave === 3 && i === 0) spawnBoss();
                else spawnEnemy();
            }
        }

        function spawnEnemy() {
            // Robot Group
            const enemy = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.8), new THREE.MeshStandardMaterial({ color: 0xaa0000 }));
            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0x550000 }));
            head.position.y = 1.1;
            // Eye
            const eye = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            eye.position.set(0, 1.1, 0.31);

            enemy.add(body, head, eye);
            
            // Random Pos
            const angle = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random() * 30;
            enemy.position.set(Math.cos(angle)*dist, 1.5, Math.sin(angle)*dist);

            enemy.userData = { hp: 3, isBoss: false };
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnBoss() {
            const boss = new THREE.Group();
            
            // Big Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 3), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            // Armor Plates
            const plate = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2, 3.2), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }));
            plate.position.y = 1;
            // Glowing Eye
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            eye.position.set(0, 1.5, 1.6);

            boss.add(body, plate, eye);
            boss.position.set(0, 3, -60); // Spawns far away

            boss.userData = { hp: 50, maxHp: 50, isBoss: true };
            
            scene.add(boss);
            enemies.push(boss);
        }

        function switchWeapon(id) {
            currentWeapon = id;
            for(let key in weaponMeshes) weaponMeshes[key].visible = false;
            weaponMeshes[id].visible = true;
            weaponText.innerText = "EQUIPPED: " + weapons[id].name;
            weaponText.style.color = "#" + weapons[id].color.toString(16);
        }

        function checkShoot() {
            const now = performance.now();
            const w = weapons[currentWeapon];

            if (now - lastShotTime > w.delay) {
                lastShotTime = now;
                if (currentWeapon === 3) throwGrenade(w);
                else fireBullet(w);
            }
        }

        function fireBullet(w) {
            // Kickback
            weaponMeshes[currentWeapon].position.z += 0.15;

            const geo = new THREE.SphereGeometry(0.08);
            const mat = new THREE.MeshBasicMaterial({ color: w.color });
            const bullet = new THREE.Mesh(geo, mat);

            // Pos
            bullet.position.copy(camera.position);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            bullet.position.add(right.multiplyScalar(0.2));
            bullet.position.y -= 0.2;

            // Dir
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            bullet.userData = { velocity: dir.multiplyScalar(w.speed), damage: w.damage };

            scene.add(bullet);
            bullets.push(bullet);
        }

        function throwGrenade(w) {
            weaponMeshes[3].visible = false;
            setTimeout(() => { if(currentWeapon===3) weaponMeshes[3].visible = true; }, 800);

            const geo = new THREE.CylinderGeometry(0.1, 0.1, 0.3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const gren = new THREE.Mesh(geo, mat);

            gren.position.copy(camera.position);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            
            const vel = dir.multiplyScalar(25);
            vel.y += 10;
            
            gren.userData = { velocity: vel, timer: 100, damage: 20 }; 

            scene.add(gren);
            grenades.push(gren);
        }

        function createExplosion(pos) {
            // Visual
            const geo = new THREE.SphereGeometry(6);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 });
            const exp = new THREE.Mesh(geo, mat);
            exp.position.copy(pos);
            scene.add(exp);
            setTimeout(() => scene.remove(exp), 150);

            // Damage Area
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (enemies[i].position.distanceTo(pos) < 10) {
                    damageEnemy(i, 20);
                }
            }
        }

        function damageEnemy(index, dmg) {
            const enemy = enemies[index];
            enemy.userData.hp -= dmg;
            
            // Flash white
            enemy.children[0].material.emissive = new THREE.Color(0xffffff);
            setTimeout(() => { if(enemy) enemy.children[0].material.emissive = new THREE.Color(0x000000); }, 50);

            if (enemy.userData.isBoss) {
                // Update Boss UI
                const pct = (enemy.userData.hp / enemy.userData.maxHp) * 100;
                bossFill.style.width = Math.max(0, pct) + "%";
            }

            if (enemy.userData.hp <= 0) {
                // Die
                scene.remove(enemy);
                enemies.splice(index, 1);
                enemiesRemaining--;
                updateEnemyCounter();

                if (enemiesRemaining <= 0) {
                    setTimeout(startNextWave, 2000); // Delay before next wave
                }
            }
        }

        function updateEnemyCounter() {
            enemyText.innerText = "ENEMIES: " + enemiesRemaining;
        }

        // --- CONTROLS ---
        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Digit1': switchWeapon(1); break;
                case 'Digit2': switchWeapon(2); break;
                case 'Digit3': switchWeapon(3); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // Physics / Movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 600.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 600.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                // Floor Collision
                if(controls.getObject().position.y < PLAYER_HEIGHT) {
                    controls.getObject().position.y = PLAYER_HEIGHT;
                    velocity.y = 0;
                }
                
                // Wall Collision (Simple Clamp)
                const pos = controls.getObject().position;
                pos.x = Math.max(-95, Math.min(95, pos.x));
                pos.z = Math.max(-95, Math.min(95, pos.z));

                // Recoil Recovery
                const wm = weaponMeshes[currentWeapon];
                if(wm) {
                    const baseZ = (currentWeapon===1)? -0.6 : -0.5;
                    if(wm.position.z > baseZ) wm.position.z -= 1 * delta;
                }

                // Rifle Auto Fire
                if (isMouseDown && weapons[currentWeapon].auto) checkShoot();

                // Bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
                    
                    if (b.position.distanceTo(camera.position) > 200) {
                        scene.remove(b); bullets.splice(i, 1); continue;
                    }

                    // Check Enemy Hits
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        // Hitbox size depends on enemy type
                        const hitDist = enemy.userData.isBoss ? 4 : 1.5;
                        
                        if (b.position.distanceTo(enemy.position) < hitDist) {
                            damageEnemy(j, b.userData.damage);
                            scene.remove(b);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }

                // Grenades
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const g = grenades[i];
                    g.userData.velocity.y -= 50 * delta; 
                    g.position.add(g.userData.velocity.clone().multiplyScalar(delta));
                    
                    g.rotation.x += 5 * delta;

                    if(g.position.y < 0.5) {
                        g.position.y = 0.5;
                        g.userData.velocity.y *= -0.5;
                        g.userData.velocity.x *= 0.6;
                        g.userData.velocity.z *= 0.6;
                    }

                    g.userData.timer--;
                    if(g.userData.timer <= 0) {
                        createExplosion(g.position);
                        scene.remove(g);
                        grenades.splice(i, 1);
                    }
                }

                // Enemy AI
                enemies.forEach(e => {
                    const speed = e.userData.isBoss ? 5 : 8;
                    const dir = new THREE.Vector3().subVectors(controls.getObject().position, e.position);
                    dir.y = 0; 
                    dir.normalize();
                    e.position.add(dir.multiplyScalar(speed * delta));
                    e.lookAt(controls.getObject().position);
                });
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
